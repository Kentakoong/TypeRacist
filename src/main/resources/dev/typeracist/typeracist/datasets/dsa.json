["#include <iostream> #include <vector> void merge(std::vector<int>& arr, int l, int m, int r) { int n1 = m - l + 1; int n2 = r - m; std::vector<int> L(n1), R(n2); for (int i = 0; i < n1; i++) L[i] = arr[l + i]; for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j]; int i = 0, j = 0, k = l; while (i < n1 && j < n2) { if (L[i] <= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } while (i < n1) { arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j]; j++; k++; } } void mergeSort(std::vector<int>& arr, int l, int r) { if (l < r) { int m = l + (r - l) / 2; mergeSort(arr, l, m); mergeSort(arr, m + 1, r); merge(arr, l, m, r); } }", "#include <iostream> #include <vector> #include <queue> #include <limits> void dijkstra(std::vector<std::vector<std::pair<int, int>>>& graph, int src, int V) { std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq; std::vector<int> dist(V, std::numeric_limits<int>::max()); pq.push({0, src}); dist[src] = 0; while (!pq.empty()) { int u = pq.top().second; pq.pop(); for (auto& edge : graph[u]) { int v = edge.first; int weight = edge.second; if (dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; pq.push({dist[v], v}); } } } }", "#include <iostream> #include <unordered_map> struct TrieNode { std::unordered_map<char, TrieNode*> children; bool isEndOfWord; TrieNode() : isEndOfWord(false) {} }; class Trie { public: TrieNode* root; Trie() : root(new TrieNode()) {} void insert(const std::string& word) { TrieNode* current = root; for (char c : word) { if (current->children.find(c) == current->children.end()) current->children[c] = new TrieNode(); current = current->children[c]; } current->isEndOfWord = true; } bool search(const std::string& word) { TrieNode* node = findNode(word); return node != nullptr && node->isEndOfWord; } bool startsWith(const std::string& prefix) { return findNode(prefix) != nullptr; } private: TrieNode* findNode(const std::string& prefix) { TrieNode* current = root; for (char c : prefix) { if (current->children.find(c) == current->children.end()) return nullptr; current = current->children[c]; } return current; } };", "#include <iostream> #include <vector> int partition(std::vector<int>& arr, int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j < high; j++) { if (arr[j] <= pivot) { i++; std::swap(arr[i], arr[j]); } } std::swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(std::vector<int>& arr, int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } }", "#include <iostream> class UnionFind { private: std::vector<int> parent, rank; public: UnionFind(int n) { parent.resize(n); rank.resize(n, 0); for (int i = 0; i < n; i++) parent[i] = i; } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } void unite(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return; if (rank[rootX] < rank[rootY]) parent[rootX] = rootY; else if (rank[rootX] > rank[rootY]) parent[rootY] = rootX; else { parent[rootY] = rootX; rank[rootX]++; } } bool connected(int x, int y) { return find(x) == find(y); } };", "#include <iostream> #include <vector> #include <algorithm> struct Edge { int src, dest, weight; Edge(int s, int d, int w) : src(s), dest(d), weight(w) {} bool operator<(const Edge& other) const { return weight < other.weight; } }; void kruskalMST(std::vector<Edge>& edges, int V) { std::sort(edges.begin(), edges.end()); UnionFind uf(V); std::vector<Edge> result; for (Edge& edge : edges) { if (!uf.connected(edge.src, edge.dest)) { uf.unite(edge.src, edge.dest); result.push_back(edge); } if (result.size() == V-1) break; } }", "#include <iostream> #include <unordered_map> #include <list> template <typename K, typename V> class LRUCache { private: int capacity; std::list<std::pair<K, V>> items; std::unordered_map<K, typename std::list<std::pair<K, V>>::iterator> cache; public: LRUCache(int cap) : capacity(cap) {} V get(K key) { if (cache.find(key) == cache.end()) return V(); // Return default value if key not found // Move to front (most recently used) items.splice(items.begin(), items, cache[key]); return cache[key]->second; } void put(K key, V value) { if (cache.find(key) != cache.end()) { // Update existing item cache[key]->second = value; items.splice(items.begin(), items, cache[key]); return; } // Check if cache is full if (cache.size() >= capacity) { // Remove least recently used item auto last = items.end(); last--; cache.erase(last->first); items.pop_back(); } // Insert new item at front items.push_front({key, value}); cache[key] = items.begin(); } };", "#include <iostream> #include <vector> void countingSort(std::vector<int>& arr, int exp) { const int n = arr.size(); std::vector<int> output(n); std::vector<int> count(10, 0); for (int i = 0; i < n; i++) count[(arr[i]/exp) % 10]++; for (int i = 1; i < 10; i++) count[i] += count[i-1]; for (int i = n-1; i >= 0; i--) { output[count[(arr[i]/exp) % 10] - 1] = arr[i]; count[(arr[i]/exp) % 10]--; } for (int i = 0; i < n; i++) arr[i] = output[i]; } void radixSort(std::vector<int>& arr) { int max_val = *std::max_element(arr.begin(), arr.end()); for (int exp = 1; max_val/exp > 0; exp *= 10) countingSort(arr, exp); }", "#include <iostream> #include <vector> #include <stack> void dfs(std::vector<std::vector<int>>& graph, int start) { std::vector<bool> visited(graph.size(), false); std::stack<int> s; s.push(start); while (!s.empty()) { int node = s.top(); s.pop(); if (!visited[node]) { std::cout << node << ' '; visited[node] = true; for (int i = graph[node].size()-1; i >= 0; i--) if (!visited[graph[node][i]]) s.push(graph[node][i]); } } }"]
